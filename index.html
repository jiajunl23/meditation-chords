<body style="background: white"></body>
<script src="https://unpkg.com/tone"></script>
<script src="https://algorithmicmusic.online/js/libs/nn.min.js"></script>
<script src="https://algorithmicmusic.online/js/viz-helpers.js"></script>
<script>
/* global Tone, nn, viz */
  
// SOURCES
// ------------------
const synth = new Tone.PolySynth()

const path = 'https://tonejs.github.io/audio/drum-samples/Stark/'
const drumset = new Tone.Players({
  kick: path + 'kick.mp3',
  snare: path + 'snare.mp3',
  hihat: path + 'hihat.mp3',
  tom1: path + 'tom1.mp3',
  tom2: path + 'tom2.mp3',
  tom3: path + 'tom3.mp3'
})

const list_players = ["kick", "snare", "hihat", "tom1", "tom2", "tom3"]

const possible_notes = ["C", "D", "E", "F", "G", "A", "B"]

// SIGNAL CHAIN
// -------------------
synth.toDestination()
drumset.toDestination()

// TRANSPORT SETUP + OTHER GLOBAL VARS
// ------------------------------------

Tone.Transport.bpm.value = 240
Tone.Transport.loop = true
Tone.Transport.timeSignature = 4
Tone.Transport.loopEnd = '10m'
  
// FUNCTIONS 
// -----------------
  
// the chance calculation 
function cal_chance(player, bar, beat){
  if (player === "kick") {
    if (bar < 5) {
      return 0
    }
    else {
      if (beat % 4 === 0) {
        return nn.random()
      } else {
        return 0
      }
    }
  }

  if (player === "snare") {
    if (bar < 5) {
      if (beat % 4 === 0) {
        return 1
      } else {
        return 0
      }
    }
    else {
      return nn.random(0, 0.8) 
    }
  }

  if (player === "hihat") {
    if (bar < 5) {
      return 0
    }
    else {
      if (nn.random() > 0.8){
        return 0
      } else{
        return 0
      }
    }
  }

  if (player === "tom1") {
    if (bar < 5) {
      if (beat % 2 === 0) {
        return 1
      } else {
        return 0
      }
    }
    else {
      return nn.random(0, 1.1)
    }
  }

  if (player === "tom2") {
    if (bar < 5) {
      if (beat % 3 === 0) {
        return 1
      } else {
        return nn.random()
      }
    }
    else {
      return nn.random()
    }
  }

  if (player === "tom3") {
    if (bar < 5) {
      if (beat % 3 === 0) {
        return 1
      } else {
        return nn.random()
      }
    }
    else {
      if (nn.random(0, 1) > 0.2) {
        return 2
      } else {
        return nn.random()
      }
    }
  }
}

function toggle () {
  if (Tone.Transport.state === 'stopped') {
    Tone.Transport.start()
    this.content('stop')
  } else {
    Tone.Transport.stop()
    this.content('start')
  }
}

function pressPianoKey (note, dur, time) {
  const delay = time + Tone.Time(dur).toSeconds()
  Tone.Draw.schedule(() => pianoKeys.attack(note), time)
  Tone.Draw.schedule(() => pianoKeys.release(note), delay)
}
  
let previous_root_index = 0

function play (time) {
  const [bar, beat] = Tone.Transport.position.split(':').map(Number)
  
  // ............................
  // musical algorithm goes here
  // ............................
  
  
  for (const player of list_players){
    if (cal_chance(player, bar, beat) > 0.5) {
      drumset.player(player).start(time)
    }
    if (cal_chance(player, bar, beat) > 1) {
      drumset.player(player).start(time + (30 / Tone.Transport.bpm.value))
    }
  }
  
  let [root, scale, root_index] = [0, 0, 0]
  
  const possible_chords = ["power-chord", "triad", "seventh"]
  
  if (beat % 2 === 0){
    root_index = nn.randomInt(0, 6)
    root = possible_notes[root_index] + nn.randomInt(4, 5)
    scale = nn.createScale(root, "major")
    previous_root_index = root_index
  } else {
    root_index = (previous_root_index + 1) % 7
    root = possible_notes[root_index] + nn.randomInt(4, 5)
    scale = nn.createScale(root, "major")
  }
  
  
  let length
  
  if (bar < 5){
    length = nn.random(["16n", "8n"])
  } else {
    length = nn.random(["8n", "4n"])
  }
        

  let chord = nn.createChord(scale, nn.random(possible_chords))
  synth.triggerAttackRelease(chord, length, time)
  
  chord.forEach(note => {
    pressPianoKey(note, length, time)
  })
}


// SETUP PLAY LOOP
// ----------------------
new Tone.Loop(play).start()

// USER INTERFACE
// ---------------------
const toggleBtn = nn.create('button')
  .content('start')
  .addTo('body')
  .on('click', toggle)

nn.create('br').addTo('body')

const pianoKeys = viz.createPianoUI({
  labels: true,
  octaves: [3, 6]
})

nn.create("br").addTo("body")
nn.create("label")
  .content("For this weeks meditation, I used the template and incorporated my last week's meditation's code of the drum beats to start with. On top of the drum beats, I added chords, and I let the roots of the chords to be chosen from the C major notes, and let the octave to be limited to a random number between 4 and 5, and the chord to be triad. After adding this, I also wanted to chords to be a bit diverse, so instead of being triad all the times, I let it be a random one among power-chord, triad, and seventh. Then, because for the drum beats, I have a intro part that has a different pace then the later part, so I also adjusted the duration of the triggerAttackRelease based on the value of bar and added some randomness into it. I also wanted some control of the root of the chords rather than complete randomness, so I added that for beat % 2 is 0, choose a random root, and for others, let root be one plus the previous root.")
  .addTo("body")

nn.create("br").addTo("body")
nn.create("br").addTo("body")
nn.create("label")
  .content("When doing this meditation, I also initially tried to use a specific hard-coded chord melody, instead of the current generated chord based on randomness, but it seems that Tone.Transport is not a suitable one to use if I want to hard-code a melody that the notes have different lengths and I want each of them to go right after the previous note is done playing. Claude recommended some alternative options, and I might experiment with that more in Final Project")
  .addTo("body")

</script>